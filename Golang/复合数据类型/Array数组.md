## 数组

----

Go语言中数组是同一种数据类型元素的集合，在声明的时候数组的大小就确定，使用时可以修改数组成员，但是大小不可以变化

```go
/* 定义一个长度为3，元素类型为int的数组 */

var a [3]int
```

### 数组的定义

```go
var 数组变量名 [元素数量]T
```

**注意：** 数组的长度必须是常量，而且长度是数组类型的一部分，一旦定义后，长度不能修改，长度不同的两个数组是不同的类型，不能进行比较

数组内的项，可以通过索引进行访问，从 0 开始到数组长度减1的位置，内置的 `len()` 函数将返回数组的长度

**注意：** 当访问不在合法范围之内的索引时，则会触发访问越界错误

### 数组的初始化

默认情况下，数组的每个元素都会被初始化为元素类型对应的零值，也可以使用对应的元素值来初始化数组

```go
var a [3]int = [3]int{1,2,3}
var b [3]int = [3]int{1,2}
var c [3]string = [3]string{"小米","大米","绿豆"}
```

可以在数组长度位置用 `...`，让数组长度根据初始化个数来计算

```go
var a := [...]int{1,2.3}
```

还可以指定一个索引和对应值列表的方式初始化

```go
const (
    USD = iota
    EUR
    RMB
)

a := [...]string{USD: "$",EUR: "€",RMB: "￥"}

fmt.Println(RMB,a[RMB])         // 2 ￥
```

在使用 `...` 让数组长度根据初始化值个数来计算时，初始化索引的顺序是无关紧要的，没用到的索引可以省略，未指定初始值的元素将用零值初始化

```go
r := [...]int{99: -1}
/* 这个数组的长度为100，最后一个元素为 -1，其他元素都为 0 */
```

### 数组的遍历

数组遍历使用 `for` 循环语句

```go
var a = [...]{1,2,3,4,5,6,7}

for i := 0; i < len(a)-1; i++ {
    fmt.Println(a[i])
}

/* *********************** */

for _, i := range a{
    fmt.Println(i)
}
```

### 多维数组

Go语言支持多维数组

```go
a := [...][2]string{
    {"a","b"},
    {"c","d"},
    {"e","f"}
}
```

**注意：** 多维数组，只有第一层可以使用 `...` 来让编译器根据初始化值个数来计算数组长度

要遍历多维数组的话，还是用 `for` 循环语句

```go
a := [...][2]string{
    {"a","b"},
    {"c","d"},
    {"e","f"}
}
for _, v1 := range a {
    for _, v2 := range v1 {
        fmt.Println(v2)
    }
}
```

### 数组的类型

Go语言的数组是值类型，这点和javascript不同(javascript是引用类型)。在Go语言中赋值和传参会复制整个数组，因此改变副本的值，不会改变原始数组本身的值

**注意：** 这里是默认情况下，除非你使用 `&` 运算符取数组的内存地址赋值或传参，这样就成为了引用类型，这可以减少赋值操作，加快程序速度

```go
a := [...]int{1,2,3,4,5,6,7}

b := &a
c := a

c[0] = 100
fmt.Println(a)          // [1 2 3 4 5 6 7]
fmt.Println(c)          // [100 2 3 4 5 6 7]

b[0] = 200
fmt.Println(*b)         // [200 2 3 4 5 6 7]
fmt.Println(a)          // [200 2 3 4 5 6 7]
```

**注意：**
1. 数组支持 `==` 、 `!=` 操作符，因为内存总是被初始化过的
2. [n]*T 表示 元素类型为 指针 的数组
3. *[n]T 表示 数组的指针
## 接口

---

接口 (interface) 定义了一个对象的行为规范，只定义规范而不进行实现，由具体的对象来实现规范的细节

### 接口类型

在Go语言中 `interface` 是一种类型，一种抽象的类型，它不会暴露出它所代表的对象的内部值的结构和这个对象支持的基础操作的集合；它们只会展示出它们自己的方法。也就是说当你有看到一个接口类型的值时，你不知道它是什么，唯一知道的就是可以通过它的方法来做什么

`interface` 是一组 `method` 的集合，是 `duck-type programming` 的一种体现

### 接口的定义

Go语言提出面向 `interface` 编程，每个 `interface` 由数个方法组成

```go
type 接口类型名 interface {
    方法名1(参数列表1) 返回值列表1
    方法名2(参数列表2) 返回值列表2
}
```

1. 接口名：使用 `type` 将接口定义为自定义的类型名，Go语言的接口在命名的时候，一般会在单词后面添加 `er`，例 `Wtiter`、`Stringer`，接口名最好能突出改接口的类型含义
2. 方法名：当方法名首字母是大写且这个接口类型名首字母也是大写时，这个方法可以被接口所在的包之外的代码访问
3. 参数列表、返回值列表：参数列表和返回值列表中的参数变量名可以省略

```go
type writer interface {
    Write([]byte) error
}
```

这个 `interface` 类型，你不知道它是什么，唯一知道的就是可以通过它的 `Write` 方法来做什么

### 实现接口的条件

一个对象只有全实现了 `interface` 中的方法，才算是实现了这个 `interface`，简单的说的话，`interface` 就是一个 **需要实现的方法列表**

```go
/* 创建接口 */
type tester interface {
    say()
}

/* 创建结构体 */
type person struct {
    name string
}

/* 给 person 结构体添加 say() 方法 */
func (p person) say() {
    fmt.Println("hello")
}
```

这样就实现了 `interface`，只要对象实现了 `interface` 中的所有方法，就算实现了这个 `interface`

### 接口的作用

定义接口后，可以通过传入参数的类型判断，传入的对象是什么，然后调用对象中存在的方法或修改对象的值

```go
type sayer interface {
    say()
}

type person struct {}

func (p person) say() {
    fmt.Println("hello")
}

type cat struct {}

func (c cat) say() {
    fmt.Println("喵喵喵")
}

type dog struct {}

func (d dog) say() {
    fmt.Println("汪汪汪")
}

/* 声明一个 参数类型为 sayer 接口的函数 */
func testSay(x sayer) {
    /* 调用结构体对象上的方法 */
    x.say()
}

func main() {
    /* 实例化结构体 */
    var p = person{}
    var c = cat{}
    var d = dog{}

    /* 传入不同的结构体对象 */
    testSay(p)      // hello
    testSay(c)      // 喵喵喵
    testSay(d)      // 汪汪汪
}
```

### 接口类型变量

`interface` 类型变量能够存储所有实现了该接口的实例

```go
type sayer interface {
    say()
}

type person struct {}

func (p person) say() {
    fmt.Println("hello")
}

type cat struct {}

func (c cat) say() {
    fmt.Println("喵喵喵")
}

func main() {
    /* 声明一个 sayer 接口类型的变量 s */
    var s sayer

    /* 实例化结构体 */
    var p = person{}
    var c = cat{}

    /* 把实例化的结构体对象赋值给 变量 s */
    s = p
    s.say()     // hello
    s = c
    s.say()     // 喵喵喵
}
```

### 值接收器和指针接收器实现接口的区别
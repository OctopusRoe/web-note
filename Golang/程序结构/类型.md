## 类型

---

变量或者表达式的类型定义了对应存储值的属性特征，如数值在内存的存储大小，它们在内部是如何表达的，是否支持一些操作符，以及它们自己关联的方法集等。

一个类型声明语句创建一个新的类型名称，和现有类型具有相同的底层结构。新命名的类型提供了一个方法，用来分隔不同概念的类型，这样即使它们底层的基础类型相同也是不兼容的。

```go
type 类型名称 底层基础类型
```

类型声明语句一般出现在包一级，因此如果新创建的类型名称的首字符大写，则在外部包也是可以使用的。

```go
/* 创建新类型 */

package tempconv

import "fmt"

type Celsius float64        // 摄氏度
type Fahrenheit float64     // 华氏度

const (
    AbsolutZeroC Celsius = -273.15
    FreezingC Celsius = 0
    BoilingC Celsius = 100
)

func CToF(c Celsius) Fahrenheit {
    return Fahrenheit(c*9/5 + 32)
}

func FToC(f Fahrenheit) Celsius{
    return Celsius(f - 32) * 5 / 9
}
```

上面的例子中，`Celsius` 和 `Fahrenheit` 虽然有着相同的底层基础类型 `float64`，但是他们是不同的数据类型，因此**不能相互比较**或者**混在同一个表达式运算**。

Celsius(t) 和 Fahrenheit(t) 是类型转换操作，他们并**不是函数调用**，类型转换不会改变值本身，但会使它们的寓意发生变化。

CToF() 和 FToC() 两个函数则是对不同温度单位下的温度进行换算，这两个方法会返回不同的值。

Go语言中只有强制类型转换，没有隐式类型转换。对于每一个类型 T ，都有一个对应的类型转换操作。

```go
T(x)                // T为类型，x为值
```

用于将 X 转换为 T类型。

**注意：** 只有当两个类型的底层基础类型相同的时候，才允许类型之间的相互转换

### 类型别名

给已经存在的类型定义可替代的名字，为了更符合上下文的名字，可以使用类型别名替换已存在的类型

```go
type yourInt = int

var a yourInt = 8

/* 类型别名只在编写阶段生效，编译后，还是原始类型 */
fmt.Printf("%T,%v"a,a)          // int 8
```

**注意：**
1. 自定义类型：在编译完成后还是自定义的类型
2. 类型别名：只在编写阶段生效，编译后，还是原始类型
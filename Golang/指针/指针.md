## 指针

---

有别于 c/c++ 中的指针，Go语言中的指针不能进行偏移和运算

要了解Go语言中的指针，需要了解3个概念：指针地址、指针类型、指针取值

### Go语言中的指针

任何程序数据载入内存后，在内存都有他们的**地址**，这就是**指针**，而为了保存一个数据在内存中的地址，就需要**指针变量**

Go语言中的指针不能进行偏移和运算，因此在Go语言中的指针操作非常简单，只有两个操作符 `&`(取地址)、`*`(根据地址取值)

#### 指针地址和指针类型

每个变量在运行时都拥有一个地址，这个地址代表变量在内存中的位置，Go语言中使用 `&` 符号放在变量前面对变量进行**取地址**操作

Go语言中的值类型 (int、float、bool、string、array、struct) 都有对应的指针类型 (*int、*int64、*string ...)

```go
var ptr = &v
```

1. v：代表被取地址的变量，类型为 T
2. ptr：指针变量用于接收地址，ptr的类型就是 *T，叫做T的指针类型，*代表指针

```go
var a int = 10
var b = &a

fmt.Printf("a:%d ptr:%p\n",a,&a)    // a:10 ptr:0xc00001a078
fmt.Printf("b:%p type:%T\n",b,b)    // b:0xc00001a078 type:*int
fmt.Println(&b)    // 0xc00000e018
```

![](../../images/golang/ptr/ptr.png)

#### 指针取值

Go语言中对普通变量使用 `&` 操作符取地址后会获得这个变量的指针，然后可以使用 `*` 操作符对指针进行取值操作

```go
var a int = 10
var b = &a

fmt.Printf("type b:%T\n",b)         // type b:*int

var c = *b

fmt.Printf("type c:%T\n",c)         // type c:int
fmt.Printf("c:%v a:%v",c,a)         // c:10 a:10
```

取地址操作符 `&` 和取值操作符 `*` 是一对互补操作符，使用 `&` 取出地址，`*` 根据地址取出地址指向的值

变量、指针地址、指针变量、取地址、取值的相互关系和特性

1. 对变量进行取地址 `&` 操作，可以获得这个变量的指针变量
2. 指针变量的值就是指针地址(内存地址)
3. 对指针变量进行取值 `*` 操作，可以获得指针变量所指向的原变量的值

通过这个特性，我们可以把原来是值类型的数据，变成引用数据类型，这可以大幅减少赋值操作，加快程序运行速度

```go
a := [...]int{1,2,3,4,5,6,7}

b := &a
c := a

c[0] = 100
fmt.Println(a)          // [1 2 3 4 5 6 7]
fmt.Println(c)          // [100 2 3 4 5 6 7]

b[0] = 200
fmt.Println(*b)         // [200 2 3 4 5 6 7]
fmt.Println(a)          // [200 2 3 4 5 6 7]
```

### new() make() 函数

Go语言中对于引用数据类型的变量，在使用的时候不仅需要进行声明，还要为变量分配内存空间，否则值就没有办法存储。

但是对于值类型的声明不需要分配内存空间，是因为在声明值类型的变量时已经默认分配好了内存空间

Go语言中使用 `new()` `make()` 两个内建函数，来分配内存

#### new() 函数

```go
new(type) *type 
```

参数名 | 介绍 |
-|-|
type | 用于接收的类型 |
*type | 返回的类型指针 |

```go
var a = new(int)
var b = new(bool)

fmt.Printf("a:%T",a)            // *int
fmt.Printf("b:%T",b)            // *bool

fmt.Println(*a)                 // 0
fmt.Println(*b)                 // false
```

`new()` 函数不常使用，使用 `new()` 函数得到的是一个类型的指针，并且该指针对应的值为该类型的零值

指针属于 **引用类型** 在使用的时候不仅需要进行声明，还要为变量分配内存空间，否则值就没有办法存储。如果在声明的时候没有进行初始化，那么只能使用 `new()` 函数进行初始化后才可以正常对其进行赋值

```go
var a int = 10
var b *int = &a

var c *int
c = new(int)
*c = a

fmt.Printf("ptr b:%p, ptr a:%p\n",b,&a) // ptr b:0xc0000120b0, ptr a:0xc0000120b0
fmt.Printf("a:%v c:%v",a,*c)            // a:10 c:10
```

#### make() 函数

`make()` 函数也用于内存分配，区别于 `new()` 函数，`make()` 函数只用于 `slice、map、channel` 数据类型的内存创建，而且 `make()` 函数返回的类型就是这三个类型的本身，而不是它们的指针类型，因为这三种类型本身就是引用类型

```go
make(Type, size ...IntegerType) Type
```

参数名 | 介绍 |
-|-|
Type | 类型 |
size | 元素个数 |
IntegerType | 可省略，容量大小 |

`make()` 函数是无可替代的，在声明 `slice、map、channel` 数据类型的时候，如果没有进行初始化，都需要使用 `make()` 函数进行初始化，然后才可以对它们进行操作

```go
var a []int

a = make([]int,5,5)

a[0] = 1

fmt.Println(a)
```

#### new() 与 make() 的区别

1. `new()` 函数和 `make()` 函数都是用来进行初始化开辟内存空间的
2. `make()` 函数只用于 `slice、map、channel` 类型的初始化，返回的还是这三个引用类型本身
3. `new()` 用于类型的内存分配，并且内存对应的值为类型的零值，返回的是指向类型的指针